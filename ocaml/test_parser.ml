open OUnit2
open Expr

type result =
  | OK of expr
  | Fail


let test_cases = [
  ("", Fail);
  ("a", OK (Var "a"));
  ("f(x, y)", OK (Call(Var "f", [Var "x"; Var "y"])));
  ("f(x)(y)", OK (Call(Call(Var "f", [Var "x"]), [Var "y"])));
  ("let f = fun x y -> g(x, y) in f(a, b)",
    OK (Let("f", Fun(["x"; "y"], Call(Var "g", [Var "x"; Var "y"])),
      Call(Var "f", [Var "a"; Var "b"]))));
  ("let x = a in " ^
  "let y = b in " ^
  "f(x, y)", OK (Let("x", Var "a", Let("y", Var "b", Call(Var "f", [Var "x"; Var "y"])))));
  ("f x", Fail);
  ("let a = one", Fail);
  ("a, b", Fail);
  ("a = b", Fail);
  ("()", Fail);
  ("fun x, y -> y", Fail);
  ]



let string_of_result = function
  | Fail -> "Fail"
  | OK expr -> "OK (" ^ string_of_expr expr ^ ")"

let make_single_test_case (code, expected_result) =
  String.escaped code >:: fun _ ->
    let result =
      try
        OK (Parser.expr_eof Lexer.token (Lexing.from_string code))
      with Parsing.Parse_error ->
        Fail
    in
    assert_equal ~printer:string_of_result expected_result result

let suite =
  "test_parser" >::: List.map make_single_test_case test_cases